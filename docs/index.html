<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arguments and Critiques</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .columns {
            display: flex;
            gap: 20px;
            overflow-x: auto;
            padding-bottom: 20px;
        }

        .column {
            min-width: 400px;
            background-color: #e8e8e8;
            border-radius: 8px;
            padding: 15px;
        }

        .column-header {
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            background-color: #d0d0d0;
            border-radius: 5px;
        }

        .panel {
            background-color: white;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            gap: 15px;
            min-height: 200px;
        }

        .argument-section {
            flex: 1;
            border-right: 2px solid #eee;
            padding-right: 15px;
        }

        .argument-text {
            line-height: 1.6;
            cursor: default;
        }

        .critiques-section {
            flex: 1;
            padding-left: 15px;
        }

        .critiques-container {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: #fafafa;
        }

        .critique {
            margin-bottom: 10px;
            padding: 8px;
            background-color: white;
            border-radius: 4px;
            border-left: 3px solid #007acc;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .critique:hover {
            background-color: #e6f3ff;
            border-left-color: #0056b3;
            box-shadow: 0 2px 8px rgba(0,122,204,0.3);
        }

        .highlighted-text {
            background-color: #fff3cd;
            border-radius: 2px;
            padding: 1px 2px;
            transition: all 0.2s ease;
        }

        .highlighted-text:hover {
            background-color: #ffeaa7;
            box-shadow: 0 0 8px rgba(255,193,7,0.6);
        }

        .highlighted-text.glow {
            background-color: #ffeaa7;
            box-shadow: 0 0 8px rgba(255,193,7,0.6);
        }

        .critique.glow {
            background-color: #e6f3ff;
            border-left-color: #0056b3;
            box-shadow: 0 2px 8px rgba(0,122,204,0.3);
        }

        .controls {
            margin-bottom: 20px;
            text-align: center;
        }

        .btn {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #0056b3;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
        }

        .modal-header {
            font-weight: bold;
            margin-bottom: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-actions {
            text-align: right;
            margin-top: 20px;
        }

        .close {
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #aaa;
        }

        .close:hover {
            color: black;
        }

        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            border: 1px solid #f5c6cb;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .loading-content {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007acc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .loading-message {
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }

        .loading-submessage {
            font-size: 14px;
            color: #666;
            line-height: 1.4;
        }

        .selection-info {
            background-color: #d1ecf1;
            color: #0c5460;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center; margin-bottom: 30px; color: #333;">Arguments and Critiques</h1>
        
        <div class="controls">
            <button class="btn" onclick="showArgumentModal()">Add Argument</button>
            <button class="btn" onclick="showCritiqueModal()">Add Critique</button>
        </div>

        <div class="columns" id="columns">
            <!-- Columns will be dynamically populated -->
        </div>

        <div id="statusMessage" class="status-message" style="display: none;"></div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-message" id="loadingMessage">Connecting to server...</div>
            <div class="loading-submessage" id="loadingSubmessage">This may take a moment</div>
        </div>
    </div>

    <!-- Add Argument Modal -->
    <div id="argumentModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('argumentModal')">&times;</span>
            <div class="modal-header">Add New Argument</div>
            <div id="argumentError"></div>
            <form onsubmit="submitArgument(event)">
                <div class="form-group">
                    <label for="argumentColumn">Column:</label>
                    <select id="argumentColumn" required>
                        <!-- Options populated dynamically -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="argumentText">Argument:</label>
                    <textarea id="argumentText" placeholder="Enter your argument..." required></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn" onclick="closeModal('argumentModal')" style="background-color: #6c757d;">Cancel</button>
                    <button type="submit" class="btn">Add Argument</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Critique Modal -->
    <div id="critiqueModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCritiqueModal()">&times;</span>
            <div class="modal-header">Add New Critique</div>
            <div id="critiqueError"></div>
            <div id="selectionInfo" class="selection-info" style="display: none;"></div>
            <form onsubmit="submitCritique(event)">
                <div class="form-group">
                    <label for="critiqueText">Critique:</label>
                    <textarea id="critiqueText" placeholder="Enter your critique..." required></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn" onclick="closeCritiqueModal()" style="background-color: #6c757d;">Cancel</button>
                    <button type="submit" class="btn">Add Critique</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const API_BASE = 'https://deliberator-app.onrender.com';
        let data = [];
        let selectedText = null;

        // Load data on page load
        document.addEventListener('DOMContentLoaded', loadData);

        async function loadData() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingMessage = document.getElementById('loadingMessage');
            const loadingSubmessage = document.getElementById('loadingSubmessage');
            const statusMessage = document.getElementById('statusMessage');
            
            // Show loading overlay
            loadingOverlay.style.display = 'flex';
            statusMessage.style.display = 'none';
            
            const startTime = Date.now();
            let coldStartWarningShown = false;
            
            // Show cold start warning after 3 seconds
            const coldStartTimer = setTimeout(() => {
                if (!coldStartWarningShown) {
                    loadingMessage.textContent = 'Backend is starting up...';
                    loadingSubmessage.textContent = 'Render services can take up to 50 seconds to wake up from sleep. Please be patient!';
                    coldStartWarningShown = true;
                }
            }, 3000);
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout
                
                const response = await fetch(`${API_BASE}/data`, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                clearTimeout(coldStartTimer);
                
                if (!response.ok) {
                    throw new Error(`Server responded with status: ${response.status}`);
                }
                
                data = await response.json();
                loadingOverlay.style.display = 'none';
                
                // Show success message if it was a slow load
                const loadTime = Date.now() - startTime;
                if (loadTime > 5000) {
                    statusMessage.className = 'status-message status-warning';
                    statusMessage.textContent = `Connected successfully! (took ${Math.round(loadTime/1000)} seconds)`;
                    statusMessage.style.display = 'block';
                    
                    // Hide success message after 5 seconds
                    setTimeout(() => {
                        statusMessage.style.display = 'none';
                    }, 5000);
                }
                
                renderColumns();
                
            } catch (error) {
                clearTimeout(coldStartTimer);
                loadingOverlay.style.display = 'none';
                
                console.error('Error loading data:', error);
                
                let errorMessage = 'Unable to connect to the server. ';
                
                if (error.name === 'AbortError') {
                    errorMessage += 'The request timed out after 60 seconds. The server may be experiencing issues.';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage += 'Please check that the backend is running and accessible.';
                } else {
                    errorMessage += error.message;
                }
                
                statusMessage.className = 'status-message status-error';
                statusMessage.innerHTML = `
                    ${errorMessage}
                    <br><br>
                    <button class="btn" onclick="loadData()" style="margin-top: 10px;">Try Again</button>
                `;
                statusMessage.style.display = 'block';
            }
        }

        function renderColumns() {
            const columnsContainer = document.getElementById('columns');
            columnsContainer.innerHTML = '';

            data.forEach((column, columnIndex) => {
                const columnDiv = document.createElement('div');
                columnDiv.className = 'column';
                
                const header = document.createElement('div');
                header.className = 'column-header';
                header.textContent = `Column ${columnIndex + 1}`;
                columnDiv.appendChild(header);

                column.forEach((panel, panelIndex) => {
                    const panelDiv = document.createElement('div');
                    panelDiv.className = 'panel';
                    panelDiv.dataset.columnIndex = columnIndex;
                    panelDiv.dataset.panelIndex = panelIndex;

                    // Argument section
                    const argumentSection = document.createElement('div');
                    argumentSection.className = 'argument-section';
                    
                    const argumentText = document.createElement('div');
                    argumentText.className = 'argument-text';
                    argumentText.innerHTML = createHighlightedText(panel.argument, panel.critiques, columnIndex, panelIndex);
                    argumentSection.appendChild(argumentText);

                    // Critiques section
                    const critiquesSection = document.createElement('div');
                    critiquesSection.className = 'critiques-section';
                    
                    const critiquesContainer = document.createElement('div');
                    critiquesContainer.className = 'critiques-container';
                    
                    if (panel.critiques.length === 0) {
                        critiquesContainer.innerHTML = '<em>No critiques yet</em>';
                    } else {
                        panel.critiques.forEach((critique, critiqueIndex) => {
                            const critiqueDiv = document.createElement('div');
                            critiqueDiv.className = 'critique';
                            critiqueDiv.textContent = critique[0];
                            critiqueDiv.dataset.columnIndex = columnIndex;
                            critiqueDiv.dataset.panelIndex = panelIndex;
                            critiqueDiv.dataset.critiqueIndex = critiqueIndex;
                            critiqueDiv.addEventListener('mouseenter', highlightCorrespondingText);
                            critiqueDiv.addEventListener('mouseleave', removeHighlight);
                            critiquesContainer.appendChild(critiqueDiv);
                        });
                    }
                    
                    critiquesSection.appendChild(critiquesContainer);

                    panelDiv.appendChild(argumentSection);
                    panelDiv.appendChild(critiquesSection);
                    columnDiv.appendChild(panelDiv);
                });

                columnsContainer.appendChild(columnDiv);
            });

            // Populate column options in modals
            populateColumnOptions();
        }

        function createHighlightedText(text, critiques, columnIndex, panelIndex) {
            if (critiques.length === 0) return text;

            // Sort critiques by start index
            const sortedCritiques = [...critiques].sort((a, b) => a[1] - b[1]);
            
            let result = '';
            let lastIndex = 0;

            sortedCritiques.forEach((critique, critiqueIndex) => {
                const [, start, end] = critique;
                
                // Add text before highlight
                result += text.slice(lastIndex, start);
                
                // Add highlighted text
                const highlightedSpan = `<span class="highlighted-text" data-column-index="${columnIndex}" data-panel-index="${panelIndex}" data-critique-index="${critiqueIndex}">${text.slice(start, end)}</span>`;
                result += highlightedSpan;
                
                lastIndex = end;
            });

            // Add remaining text
            result += text.slice(lastIndex);

            return result;
        }

        function highlightCorrespondingText(event) {
            const critiqueElement = event.target;
            const columnIndex = critiqueElement.dataset.columnIndex;
            const panelIndex = critiqueElement.dataset.panelIndex;
            const critiqueIndex = critiqueElement.dataset.critiqueIndex;

            // Add glow to critique
            critiqueElement.classList.add('glow');

            // Find and highlight corresponding text
            const textSpan = document.querySelector(
                `.highlighted-text[data-column-index="${columnIndex}"][data-panel-index="${panelIndex}"][data-critique-index="${critiqueIndex}"]`
            );
            if (textSpan) {
                textSpan.classList.add('glow');
            }
        }

        function removeHighlight(event) {
            const critiqueElement = event.target;
            const columnIndex = critiqueElement.dataset.columnIndex;
            const panelIndex = critiqueElement.dataset.panelIndex;
            const critiqueIndex = critiqueElement.dataset.critiqueIndex;

            // Remove glow from critique
            critiqueElement.classList.remove('glow');

            // Remove highlight from corresponding text
            const textSpan = document.querySelector(
                `.highlighted-text[data-column-index="${columnIndex}"][data-panel-index="${panelIndex}"][data-critique-index="${critiqueIndex}"]`
            );
            if (textSpan) {
                textSpan.classList.remove('glow');
            }
        }

        // Add event listeners for text highlighting
        document.addEventListener('mouseup', handleTextSelection);

        function handleTextSelection() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0 || selection.toString().trim() === '') {
                selectedText = null;
                return;
            }

            const range = selection.getRangeAt(0);
            
            // Find the argument section that contains the selection
            let argumentSection = null;
            let currentNode = range.commonAncestorContainer;
            
            // Walk up the DOM tree to find the argument section
            while (currentNode && currentNode !== document) {
                if (currentNode.classList && currentNode.classList.contains('argument-section')) {
                    argumentSection = currentNode;
                    break;
                }
                if (currentNode.closest && currentNode.closest('.argument-section')) {
                    argumentSection = currentNode.closest('.argument-section');
                    break;
                }
                currentNode = currentNode.parentNode;
            }

            if (!argumentSection) {
                selectedText = null;
                return;
            }

            const panel = argumentSection.closest('.panel');
            if (!panel) {
                selectedText = null;
                return;
            }

            const columnIndex = parseInt(panel.dataset.columnIndex);
            const panelIndex = parseInt(panel.dataset.panelIndex);

            // Get the argument text element
            const argumentTextElement = argumentSection.querySelector('.argument-text');
            if (!argumentTextElement) {
                selectedText = null;
                return;
            }

            // Calculate character positions relative to the plain text
            const selectedTextContent = selection.toString().trim();
            const fullText = data[columnIndex][panelIndex].argument;
            
            // Get all text nodes in the argument text element
            const textNodes = [];
            const walker = document.createTreeWalker(
                argumentTextElement,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }

            // Find the start and end positions in the original text
            let currentPosition = 0;
            let startIndex = -1;
            let endIndex = -1;
            let foundStart = false;
            let foundEnd = false;

            for (let textNode of textNodes) {
                const nodeText = textNode.textContent;
                const nodeLength = nodeText.length;
                
                // Check if this node contains the start of the selection
                if (!foundStart && range.startContainer === textNode) {
                    startIndex = currentPosition + range.startOffset;
                    foundStart = true;
                }
                
                // Check if this node contains the end of the selection
                if (!foundEnd && range.endContainer === textNode) {
                    endIndex = currentPosition + range.endOffset;
                    foundEnd = true;
                }
                
                // If we're looking for start/end in different nodes
                if (!foundStart && range.startContainer.parentNode && 
                    textNode.parentNode.contains(range.startContainer)) {
                    // Complex case - selection spans multiple elements
                    const nodeRange = document.createRange();
                    nodeRange.selectNodeContents(textNode);
                    if (range.compareBoundaryPoints(Range.START_TO_START, nodeRange) <= 0 &&
                        range.compareBoundaryPoints(Range.START_TO_END, nodeRange) >= 0) {
                        startIndex = currentPosition;
                        foundStart = true;
                    }
                }
                
                currentPosition += nodeLength;
                
                if (foundStart && foundEnd) break;
            }

            // Fallback: try to find the text by content matching
            if (startIndex === -1 || endIndex === -1) {
                const plainTextContent = argumentTextElement.textContent;
                const selectionStart = plainTextContent.indexOf(selectedTextContent);
                if (selectionStart !== -1) {
                    startIndex = selectionStart;
                    endIndex = selectionStart + selectedTextContent.length;
                }
            }

            // Validate the selection
            if (startIndex === -1 || endIndex === -1 || startIndex >= endIndex) {
                selectedText = null;
                return;
            }

            // Double-check that our indices match the selected text
            const extractedText = fullText.substring(startIndex, endIndex);
            if (extractedText !== selectedTextContent) {
                // Try one more fallback approach
                let bestMatch = -1;
                let bestScore = 0;
                
                for (let i = 0; i <= fullText.length - selectedTextContent.length; i++) {
                    const candidate = fullText.substring(i, i + selectedTextContent.length);
                    if (candidate === selectedTextContent) {
                        bestMatch = i;
                        break;
                    }
                    // Fuzzy matching as last resort
                    const score = similarity(candidate, selectedTextContent);
                    if (score > bestScore && score > 0.9) {
                        bestScore = score;
                        bestMatch = i;
                    }
                }
                
                if (bestMatch === -1) {
                    selectedText = null;
                    return;
                }
                
                startIndex = bestMatch;
                endIndex = bestMatch + selectedTextContent.length;
            }

            selectedText = {
                columnIndex,
                panelIndex,
                text: selectedTextContent,
                startIndex,
                endIndex
            };
        }

        // Simple similarity function for fuzzy matching
        function similarity(s1, s2) {
            const longer = s1.length > s2.length ? s1 : s2;
            const shorter = s1.length > s2.length ? s2 : s1;
            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = [];
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[str2.length][str1.length];
        }

        function populateColumnOptions() {
            const select = document.getElementById('argumentColumn');
            select.innerHTML = '';
            
            data.forEach((_, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Column ${index + 1}`;
                select.appendChild(option);
            });
        }

        function showArgumentModal() {
            document.getElementById('argumentModal').style.display = 'block';
            document.getElementById('argumentError').innerHTML = '';
        }

        function showCritiqueModal() {
            if (!selectedText) {
                alert('Please select text from an argument first to add a critique.');
                return;
            }

            document.getElementById('critiqueModal').style.display = 'block';
            document.getElementById('critiqueError').innerHTML = '';
            
            const selectionInfo = document.getElementById('selectionInfo');
            selectionInfo.style.display = 'block';
            selectionInfo.innerHTML = `Selected text: "${selectedText.text}" (Column ${selectedText.columnIndex + 1}, Panel ${selectedText.panelIndex + 1})`;
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function closeCritiqueModal() {
            document.getElementById('critiqueModal').style.display = 'none';
            document.getElementById('selectionInfo').style.display = 'none';
            // Clear selection
            window.getSelection().removeAllRanges();
            selectedText = null;
        }

        async function submitArgument(event) {
            event.preventDefault();
            
            const columnIndex = parseInt(document.getElementById('argumentColumn').value);
            const argumentText = document.getElementById('argumentText').value.trim();
            
            try {
                const response = await fetch(`${API_BASE}/argument`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        column_index: columnIndex,
                        argument: argumentText
                    })
                });

                if (response.ok) {
                    closeModal('argumentModal');
                    document.getElementById('argumentText').value = '';
                    await loadData();
                } else {
                    const error = await response.json();
                    document.getElementById('argumentError').innerHTML = `<div class="error">${error.detail}</div>`;
                }
            } catch (error) {
                console.error('Error submitting argument:', error);
                document.getElementById('argumentError').innerHTML = '<div class="error">Network error. Please try again.</div>';
            }
        }

        async function submitCritique(event) {
            event.preventDefault();
            
            if (!selectedText) {
                document.getElementById('critiqueError').innerHTML = '<div class="error">No text selected</div>';
                return;
            }
            
            const critiqueText = document.getElementById('critiqueText').value.trim();
            
            try {
                const response = await fetch(`${API_BASE}/critique`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        column_index: selectedText.columnIndex,
                        panel_index: selectedText.panelIndex,
                        critique_text: critiqueText,
                        start_ind: selectedText.startIndex,
                        end_ind: selectedText.endIndex
                    })
                });

                if (response.ok) {
                    closeCritiqueModal();
                    document.getElementById('critiqueText').value = '';
                    await loadData();
                } else {
                    const error = await response.json();
                    document.getElementById('critiqueError').innerHTML = `<div class="error">${error.detail}</div>`;
                }
            } catch (error) {
                console.error('Error submitting critique:', error);
                document.getElementById('critiqueError').innerHTML = '<div class="error">Network error. Please try again.</div>';
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const argumentModal = document.getElementById('argumentModal');
            const critiqueModal = document.getElementById('critiqueModal');
            
            if (event.target === argumentModal) {
                closeModal('argumentModal');
            }
            if (event.target === critiqueModal) {
                closeCritiqueModal();
            }
        }
    </script>
</body>
</html>
