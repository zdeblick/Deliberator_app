<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Argument & Critiques</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 20px;
      font-family: sans-serif;
    }
    .columns {
      display: flex;
      gap: 20px;
    }
    .column {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .panel {
      display: flex;
      border: 1px solid #ccc;
      padding: 10px;
      gap: 20px;
    }
    .argument, .critiques {
      width: 300px;
      overflow-y: auto;
      max-height: 200px;
      padding: 5px;
      border: 1px solid #eee;
    }
    .highlight {
      background-color: yellow;
    }
    .critique-item:hover {
      background-color: #ffeaa7;
      cursor: pointer;
    }
    #input-area {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
  </style>
</head>
<body>
  <div class="columns" id="content"></div>
  <div id="input-area">
    <textarea id="critiqueInput" placeholder="Enter your critique here..."></textarea>
    <button id="submitCritique">Submit Critique</button>
  </div>

  <script>
    const backendURL = "https://deliberator-app.onrender.com";

    let currentHighlight = null;
    let argumentMap = new Map();

    async function fetchData(endpoint) {
      try {
        const res = await fetch(`${backendURL}${endpoint}`);
        if (!res.ok) throw new Error("Failed to fetch");
        return await res.json();
      } catch (err) {
        console.error("Fetch error:", err);
        return null;
      }
    }

    function renderData(data) {
      const container = document.getElementById("content");
      container.innerHTML = "";

      data.forEach(col => {
        const columnEl = document.createElement('div');
        columnEl.className = 'column';

        col.forEach(panelData => {
          const panel = document.createElement('div');
          panel.className = 'panel';

          const argDiv = document.createElement('div');
          argDiv.className = 'argument';
          const rawArg = panelData.argument;

          const spanMap = {}; // key = index, value = span element

          for (let i = 0; i < rawArg.length; i++) {
            const span = document.createElement('span');
            span.textContent = rawArg[i];
            span.dataset.index = i;
            argDiv.appendChild(span);
            spanMap[i] = span;
          }

          const critDiv = document.createElement('div');
          critDiv.className = 'critiques';

          panelData.critiques.forEach((c, idx) => {
            const [text, start, end] = c;
            const item = document.createElement('div');
            item.className = 'critique-item';
            item.textContent = text;

            item.addEventListener('mouseenter', () => {
              for (let i = start; i < end; i++) {
                spanMap[i]?.classList.add('highlight');
              }
            });

            item.addEventListener('mouseleave', () => {
              for (let i = start; i < end; i++) {
                spanMap[i]?.classList.remove('highlight');
              }
            });

            critDiv.appendChild(item);
          });

          // Argument to critique hover (reverse mapping)
          Object.keys(spanMap).forEach(i => {
            const span = spanMap[i];
            span.addEventListener('mouseenter', () => {
              panelData.critiques.forEach(([text, start, end], idx) => {
                if (i >= start && i < end) {
                  critDiv.children[idx]?.classList.add('highlight');
                }
              });
            });
            span.addEventListener('mouseleave', () => {
              panelData.critiques.forEach(([text, start, end], idx) => {
                if (i >= start && i < end) {
                  critDiv.children[idx]?.classList.remove('highlight');
                }
              });
            });
          });

          // Capture argument data
          argumentMap.set(argDiv, rawArg);

          // Highlight logic
          argDiv.addEventListener('mouseup', () => {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            const range = selection.getRangeAt(0);
            if (!argDiv.contains(range.startContainer) || !argDiv.contains(range.endContainer)) return;

            let startIdx = parseInt(range.startContainer.parentElement?.dataset.index || 0);
            let endIdx = parseInt(range.endContainer.parentElement?.dataset.index || 0) + 1;
            if (startIdx > endIdx) [startIdx, endIdx] = [endIdx, startIdx];

            currentHighlight = {
              argumentText: rawArg,
              start: startIdx,
              end: endIdx
            };
          });

          panel.appendChild(argDiv);
          panel.appendChild(critDiv);
          columnEl.appendChild(panel);
        });

        container.appendChild(columnEl);
      });
    }

    document.getElementById("submitCritique").addEventListener("click", async () => {
      const critiqueText = document.getElementById("critiqueInput").value.trim();
      if (!critiqueText) {
        alert("Please enter a critique.");
        return;
      }
      if (!currentHighlight) {
        alert("Please highlight some text in an argument before submitting.");
        return;
      }

      const payload = {
        argument: currentHighlight.argumentText,
        critique: critiqueText,
        start: currentHighlight.start,
        end: currentHighlight.end
      };

      try {
        const res = await fetch(`${backendURL}/submit`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error("Submission failed");
        location.reload();
      } catch (err) {
        console.error("Error submitting critique:", err);
        alert("Failed to submit critique.");
      }
    });

    // Load data
    fetchData("/data").then(data => {
      if (data) renderData(data);
    });
  </script>
</body>
</html>
