<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Argument & Critiques</title>
  <style>
    body {
      display: flex;
      gap: 20px;
      padding: 20px;
      font-family: sans-serif;
    }
    .column {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .panel {
      display: flex;
      border: 1px solid #ccc;
      padding: 10px;
      gap: 20px;
    }
    .argument, .critiques {
      width: 300px;
      overflow-y: auto;
      max-height: 200px;
      padding: 5px;
      border: 1px solid #eee;
    }
    .highlight {
      background-color: yellow;
    }
    .selected {
      background-color: orange;
    }
    .critique-item:hover {
      background-color: #ffeaa7;
      cursor: pointer;
    }
    .input-section {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
    }
  </style>
</head>
<body>
  <script>
    const backendURL = "https://deliberator-app.onrender.com";

    async function fetchData(endpoint) {
      try {
        const res = await fetch(`${backendURL}${endpoint}`);
        if (!res.ok) throw new Error("Failed to fetch");
        return await res.json();
      } catch (err) {
        console.error("Fetch error:", err);
        return null;
      }
    }

    function clearHighlights() {
      document.querySelectorAll('.selected').forEach(el => {
        el.classList.remove('selected');
      });
    }

    function renderData(data) {
      data.forEach(col => {
        const columnEl = document.createElement('div');
        columnEl.className = 'column';

        col.forEach(panelData => {
          const panel = document.createElement('div');
          panel.className = 'panel';

          const argDiv = document.createElement('div');
          argDiv.className = 'argument';
          const rawArg = panelData.argument;
          const spanMap = {};

          let selectionStart = null;
          let selectionEnd = null;

          for (let i = 0; i < rawArg.length; i++) {
            const span = document.createElement('span');
            span.textContent = rawArg[i];
            span.dataset.index = i;
            argDiv.appendChild(span);
            spanMap[i] = span;
          }

          const critDiv = document.createElement('div');
          critDiv.className = 'critiques';

          panelData.critiques.forEach((c, idx) => {
            const [text, start, end] = c;
            const item = document.createElement('div');
            item.className = 'critique-item';
            item.textContent = text;

            item.addEventListener('mouseenter', () => {
              for (let i = start; i < end; i++) {
                spanMap[i]?.classList.add('highlight');
              }
            });
            item.addEventListener('mouseleave', () => {
              for (let i = start; i < end; i++) {
                spanMap[i]?.classList.remove('highlight');
              }
            });

            critDiv.appendChild(item);
          });

          Object.keys(spanMap).forEach(i => {
            const span = spanMap[i];
            span.addEventListener('mouseenter', () => {
              panelData.critiques.forEach(([text, start, end], idx) => {
                if (i >= start && i < end) {
                  critDiv.children[idx]?.classList.add('highlight');
                }
              });
            });
            span.addEventListener('mouseleave', () => {
              panelData.critiques.forEach(([text, start, end], idx) => {
                if (i >= start && i < end) {
                  critDiv.children[idx]?.classList.remove('highlight');
                }
              });
            });
          });

          // Selection and submit logic
          argDiv.addEventListener('mouseup', () => {
            clearHighlights();
            const sel = window.getSelection();
            if (!sel.anchorNode || !sel.focusNode) return;

            const startNode = sel.anchorNode.parentElement;
            const endNode = sel.focusNode.parentElement;
            if (!startNode.dataset.index || !endNode.dataset.index) return;

            selectionStart = Math.min(+startNode.dataset.index, +endNode.dataset.index);
            selectionEnd = Math.max(+startNode.dataset.index, +endNode.dataset.index) + 1;

            for (let i = selectionStart; i < selectionEnd; i++) {
              spanMap[i]?.classList.add('selected');
            }
          });

          const input = document.createElement('textarea');
          input.placeholder = "Enter your critique...";
          const button = document.createElement('button');
          button.textContent = "Submit Critique";

          button.addEventListener('click', async () => {
            if (selectionStart === null || selectionEnd === null) {
              alert("Please highlight some text in an argument before submitting.");
              return;
            }
            const text = input.value.trim();
            if (!text) {
              alert("Please enter a critique.");
              return;
            }

            const payload = {
              argument_text: rawArg,
              critique_text: text,
              start_index: selectionStart,
              end_index: selectionEnd
            };

            const res = await fetch(`${backendURL}/submit`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });

            const result = await res.json();
            if (result.status === "success") {
              location.reload();
            } else {
              alert("Error submitting critique: " + result.message);
            }
          });

          const inputSection = document.createElement('div');
          inputSection.className = 'input-section';
          inputSection.appendChild(input);
          inputSection.appendChild(button);

          panel.appendChild(argDiv);
          panel.appendChild(critDiv);
          panel.appendChild(inputSection);
          columnEl.appendChild(panel);
        });

        document.body.appendChild(columnEl);
      });
    }

    fetchData("/data").then(data => {
      if (data) renderData(data);
    });
  </script>
</body>
</html>
